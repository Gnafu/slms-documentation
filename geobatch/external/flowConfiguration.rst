Flow configuration
==================

GeoBatch is based on flows, where specific *events* trigger a sequence of associated *actions*.

Events are generated by an *Event Generator*, which builds a queue of events controlled by the *Event Dispatcher* (producer-consumer). The Event Dispatcher starts an *Event Consumer* thread which effectively runs *actions* sequentially, as specified in the *flow* file.

Actually GeoBatch is using Xstream so flows are defined as XML files stored into ``GEOBATCH_CONFIG_DIR``. Here is an example of a flow configuration outline:

.. sourcecode:: xml

  <?xml version="1.0" encoding="UTF-8"?>
  <FlowConfiguration>
    <id></id>
    <name></name>
    <description></description>
    ...
    <corePoolSize>10</corePoolSize>
    <maximumPoolSize>30</maximumPoolSize>
    <keepAliveTime>150</keepAliveTime> <!--seconds-->
    <workQueueSize>100</workQueueSize>
    <!-- keep consumer instance into memory map until they are manually removed -->
    <keepConsumers>false</keepConsumers>
    <!-- maximum number of consumer instances -->
    <maxStoredConsumers>6</maxStoredConsumers>

    <EventGeneratorConfiguration>
      <serviceID></serviceID>
      ...
    </EventGeneratorConfiguration>

    <EventConsumerConfiguration>
      <!-- keep runtime dir when consumer instance is disposed -->
      <keepRuntimeDir>[true|false]<keepRuntimeDir>
      ...
      <ACTION_1_Configuration>
        ...
      </ACTION_1_Configuration>
      ...
      <ACTION_N_Configuration>
        ...
      </ACTION_N_Configuration>
    </EventConsumerConfiguration>

    <ListenerConfigurations>
      ...
    </ListenerConfigurations>	
  </FlowConfiguration>


Identifiers
...........

The ``<FlowConfiguration>`` represents an *identifiable* resource, so you have to specify an ``id``, a ``name`` and a ``description``:

.. sourcecode:: xml

    <id>FLOW_ID</id>
    <name>FLOW_NAME</name>
    <description>FLOW_DESCRIPTION</description>

The ``id`` has to be the same as the flow configuration file name. For example, a file called ``example_flow.xml`` will contain:

.. sourcecode:: xml

    <id>example_flow</id>


Working directory
.................

Can be relative to the ``GEOBATCH_CONFIG_DIR``, or an absolute path:

.. sourcecode:: xml

    <workingDirectory>CONSUMER_WORKING_DIR</workingDirectory>

If not specified, it will be assumed to be ``GEOBATCH_CONFIG_DIR/FLOW_ID``.


Thread pool
...........

Each Flow configuration is handled by a Flow Manager instance which creates a new ``ThreadPoolExecutor`` with the given initial parameters and default thread factory and handler. It may be more convenient to use one of the Executor's factory methods instead of this general purpose constructor.

Elements:

* ``<corePoolSize>``: The number of threads to keep in the pool, even if they are idle.
* ``<maximumPoolSize>``: The maximum number of threads to allow in the pool.
* ``<keepAliveTime>``: When the number of threads is greater than the core pool size, this is the maximum time (in seconds) that the exceeding threads will live in idle state.
* ``<workQueueSize>``: the size of the queue to use for holding tasks before they are executed. This queue will hold only the Runnable tasks submitted by the execute method. 

.. sourcecode:: xml

  <?xml version="1.0" encoding="UTF-8"?>
  <FlowConfiguration>
    <id>FLOW_NAME</id>
    <name>NAME</name>
    <description>DESCRIPTION</description>

    <workingDirectory>geotiff</workingDirectory>
    <autorun>true</autorun>

    <corePoolSize>10</corePoolSize>
    <maximumPoolSize>30</maximumPoolSize>
    <keepAliveTime>150</keepAliveTime> <!--seconds-->
    <workQueueSize>100</workQueueSize>
    ...
  </FlowConfiguration>


Consumer configuration
......................

This is an *identifiable* component so you have to specify ``id``, ``name`` and ``description``. Plus:

* ``<listenerId>``: List of listeners used by this consumer, specified by ID (see `listener configuration`_ for details).
* ``<preserveInput>``: ``true`` to preserve input files. Defaults to ``false``. If this flag is set to ``true`` the consumer will work directly on the input data. Please be careful with this option since the event generator can trigger events on file modification.
* ``<workingDirectory>``: temporary directory to work on data, when ``preserveInput`` is set to ``false``. Can be relative to the flow working dir, or an absolute path. The actual working directory is created under this one, using a timestamp.
* ``<performBackup>``: ``true`` to create a directory called ``backup`` under the working directory. Defaults to ``false``.
* ``<FileEventRule>``: Contains child elements defining event rules.
* **Actions**: A list of actions. Element names depend on the type of action to be performed.

.. sourcecode:: xml

  <EventConsumerConfiguration>
    <id>CONSUMER_ID</id>
    <name>CONSUMER_NAME</name>
    <description>CONSUMER_DESCRIPTION</description>

    <listenerId>ConsumerLogger0</listenerId>
    ...
    <listenerId>ConsumerCumulator0</listenerId>

    <preserveInput>false</preserveInput>
    <workingDirectory>CONSUMER_WORKING_DIR</workingDirectory>
    <performBackup>false</performBackup>
    <FileEventRule>
      ...
    </FileEventRule>
    <ACTION_1_Configuration>
      ...
    </ACTION_1_Configuration>
    ...
    <ACTION_N_Configuration>
      ...
    </ACTION_N_Configuration>
  </EventConsumerConfiguration>


File event rules
^^^^^^^^^^^^^^^^

The ``FileEventRule`` defines a file name matching filter to be checked before ingestion starts. An event consumer configuration may contain many file event rules. Each ``FileEventRule`` is an *identifiable* component, so remember to specify ``id``, ``name`` and ``description``. Other elements are:

* ``<optional>``: Specifies if this rule is mandatory or not to start the ingestion. Defaults to ``false``.
* ``<originalOccurrencies>``: The number of file occurrences which should match this rule. Positive integer.
* ``<regex>``: A regular expression which should match the input file name. Example: ``<regex>.*\..*</regex>``.

.. sourcecode:: xml

  <FileEventRule>
    <optional>false</optional>
    <originalOccurrencies>1</originalOccurrencies>
    <regex>.*\..*</regex>
    <id>rule_1_id</id>
    <description>description</description>
    <name>rule_1</name>
  </FileEventRule>
  ...
  <FileEventRule>
    ...
  </FileEventRule>


Event generator
...............

Actually, the only supported event generator is the *File System Event Generator*.

.. sourcecode:: xml

  <EventGeneratorConfiguration>
    <serviceID>fsEventGeneratorService</serviceID>
    ...
  </EventGeneratorConfiguration>


Filesystem Event Generator
^^^^^^^^^^^^^^^^^^^^^^^^^^

Again, it is an *identifiable* object, with an id, a name and a description. Other elements:

* ``<interval>``: Polling interval (in milliseconds). Positive long integer (ranging 1 to 2e63-1). Defaults to 5000.

Example:

.. sourcecode:: xml

  <EventGeneratorConfiguration>
    <serviceID>fsEventGeneratorService</serviceID>
    ...
    <id>geotiff_id</id>
    <description>description</description>
    <name>geotiff</name>

    <wildCard>*.*</wildCard>
    <watchDirectory>geotiff/in</watchDirectory>
    <osType>OS_UNDEFINED</osType>
    <eventType>FILE_ADDED</eventType>
    <interval>10000</interval>
    ...
  </EventGeneratorConfiguration>


Listener configuration
......................

Each listener configuration is referred from other places using the ``<listenerId>`` element, whose value corresponds to the listener's ``<id>`` value.

* ``<id>``: Listener's identifier.
* ``<serviceID>``: Represents an alias id for the class to use and (actually) can be:

  * *cumulatingListenerService*: It is a service that is used to instantiate ProgressCumulatingListener (class), which is used by graphical interface to send status messages to the graphical interface, and must be configured at the level of consumer.
  * *statusListenerService*: It is a service that is used to instantiate ProgressStatusListener (class), which serve to define lists that are graphical interface used to monitor the status of individual actions accordingly edition should be used only in the configuration of an 'action.
  * *loggingListenerService*: It is a service that is used to instantiate ProgressLoggingListener (class), is used to log events in progress. For example: 

    1. *Consumer started*
    2. *Action started*
    3. *Action concluded*

.. sourcecode:: xml

  <ListenerConfigurations>
    <CumulatingProgressListener>
      <serviceID>cumulatingListenerService</serviceID>
      <id>ConsumerLogger0</id>
    </CumulatingProgressListener>

    <StatusProgressListener>
      <serviceID>statusListenerService</serviceID>
      <id>ActionListener0</id>
    </StatusProgressListener>		

    <LoggingProgressListener>
      <serviceID>loggingListenerService</serviceID>
      <id>ActionListener1</id>
      <loggerName>ActionListener1</loggerName>
    </LoggingProgressListener>

    <LoggingProgressListener>
      <serviceID>loggingListenerService</serviceID>
      <id>ConsumerLogger0</id>
      <loggerName>ConsumerLogger0</loggerName>
    </LoggingProgressListener>
  </ListenerConfigurations>
